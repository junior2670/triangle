WEBVTT

00:00.000 --> 00:07.039
Salut Ã  tous, c'est Florian du site ITKone,
bienvenue dans cette nouvelle vidÃ©o dÃ©diÃ©e au

00:07.039 --> 00:11.800
scripting bash oÃ¹ nous allons apprendre Ã 
utiliser les boucles FOR qui vont Ã©galement

00:11.800 --> 00:15.680
permettre de faire ce que l'on pourrait appeler
des boucles FOREACH. Les boucles FOR vont Ãªtre

00:15.680 --> 00:20.479
trÃ¨s intÃ©ressantes pour automatiser l'exÃ©cution
de tÃ¢ches rÃ©pÃ©titives, notamment sur un ensemble

00:20.479 --> 00:24.479
d'Ã©lÃ©ments. Cela peut Ãªtre sur toutes les
lignes d'un fichier ou un certain nombre de fois

00:24.479 --> 00:29.120
etc. en fonction des besoins. Cette vidÃ©o est
la troisiÃ¨me sur le sujet du scripting bash

00:29.440 --> 00:33.279
j'espÃ¨re qu'elle vous plaira. Avant de regarder
la suite, pensez Ã  vous abonner Ã  la chaÃ®ne

00:33.279 --> 00:42.599
YouTube ITKonect. Nous allons voir qu'en scripting
bash, il y a deux syntaxes diffÃ©rentes pour

00:42.599 --> 00:46.560
utiliser les boucles FOR. D'ailleurs, cette
premiÃ¨re syntaxe prÃ©sente Ã  l'Ã©cran correspond

00:46.560 --> 00:50.400
en quelque sorte Ã  du FOREACH puisqu'on va
pouvoir parcourir par exemple l'ensemble des

00:50.400 --> 00:56.159
lignes d'un fichier sans faire d'efforts
particuliers en termes de syntaxe. Ce que

00:56.159 --> 01:00.240
l'on va tout simplement Ã©crire, c'est dÃ©jÃ  le
mot clÃ© FOR. C'est toujours ce mot clÃ©, peu

01:00.240 --> 01:05.919
importe la syntaxe qu'on va utiliser. DerriÃ¨re, on
va dÃ©finir une variable qui va Ãªtre propre Ã  la

01:05.919 --> 01:09.760
boucle et qui va nous permettre de parcourir les
Ã©lÃ©ments les uns aprÃ¨s les autres. Ensuite

01:09.760 --> 01:14.360
IN et derriÃ¨re on met notre liste d'Ã©lÃ©ments.
Cela peut Ãªtre simplement une liste de quelques

01:14.360 --> 01:19.599
valeurs ou un fichier, ce qui va permettre de
dire Ã  la boucle FOR qu'elle doit parcourir

01:19.599 --> 01:23.680
l'intÃ©gralitÃ© des lignes du fichier. Dans
ce cas, on va partir de la premiÃ¨re ligne

01:23.680 --> 01:28.400
on va aller jusqu'Ã  la derniÃ¨re et on va pouvoir
appliquer une action de faÃ§on rÃ©pÃ©titive sur

01:28.400 --> 01:33.680
l'ensemble des Ã©lÃ©ments. Une fois qu'on a Ã©crit
cette premiÃ¨re ligne, on va venir mettre le DOO

01:33.680 --> 01:39.440
et Ã  la fin le DONE. Entre le DOO et le DONE,
on va venir Ã©crire l'ensemble du code que l'on

01:39.440 --> 01:46.360
veut exÃ©cuter pour chaque Ã©lÃ©ment Ã  traiter.
C'est la premiÃ¨re syntaxe d'une boucle FOR. Si

01:46.360 --> 01:50.199
l'on essaie de la mettre en pratique assez
rapidement, voici un script trÃ¨s basique

01:50.400 --> 01:55.040
On a FOR i, et dans ce cas-lÃ  le i sera la variable
que je vais pouvoir utiliser Ã  l'intÃ©rieur de la

01:55.040 --> 02:02.519
boucle IN. Je dÃ©finis un tableau de valeur de 1
jusqu'Ã  5. On va simplement Ã©crire Ã©tape numÃ©ro

02:02.519 --> 02:08.399
$i, c'est-Ã -dire Ã©tape numÃ©ro 1, numÃ©ro 2,
etc. jusqu'Ã  5, en principe compte tenu du

02:08.399 --> 02:13.880
fonctionnement d'une boucle FOR. On va pouvoir
exÃ©cuter ce premier script comme ceci. J'ai bien

02:13.880 --> 02:19.520
le retour Ã©tape numÃ©ro 1, numÃ©ro 2, etc. jusqu'Ã 
la 5. Une fois qu'on est arrivÃ© Ã  la fin de la

02:19.520 --> 02:24.320
liste d'Ã©lÃ©ments, la boucle s'arrÃªte. Comme je
n'ai rien d'autre dans mon script, on voit que j'ai

02:24.320 --> 02:28.759
bien le retour console qui apparaÃ®t Ã  l'Ã©cran.
Nous allons voir maintenant la seconde syntaxe

02:28.759 --> 02:33.839
possible. Dans ce cas-lÃ , on va partir toujours
avec le mot clÃ© FOR, et on va avoir entre double

02:33.839 --> 02:40.240
parenthÃ¨se trois valeurs Ã  indiquer. DÃ©jÃ  c'est
l'Ã©tat initial, typiquement le $i qui est Ã©gal Ã  1

02:40.240 --> 02:45.440
ou Ã  0, c'est souvent ce qu'on fait dans les
boucles FOR dans les diffÃ©rents langages. Point

02:45.440 --> 02:49.479
virgule la condition de rÃ©pÃ©tition, c'est Ã 
dire une condition Ã  Ã©valuer qui va permettre de

02:49.479 --> 02:55.160
dÃ©terminer si oui ou non on doit continuer Ã 
exÃ©cuter le bloc de code prÃ©sent dans la boucle

02:55.160 --> 03:01.720
ou au contraire si on doit sortir de la boucle.
Point virgule l'Ã©lÃ©ment Ã  incrÃ©menter Ã  chaque

03:01.720 --> 03:06.399
itÃ©ration. On va avoir une variable qui va Ãªtre
notre Ã©tat initial, que l'on va incrÃ©menter Ã

03:06.399 --> 03:10.679
chaque itÃ©ration, c'est Ã  dire Ã  chaque tour de
boucle, de maniÃ¨re Ã  un moment donnÃ© Ã  pouvoir

03:10.759 --> 03:16.800
sortir, puisqu'on va Ã©valuer cette variable au
niveau de la condition de rÃ©pÃ©tition. Si on

03:16.800 --> 03:21.199
reprend exactement le mÃªme principe que ce que
je viens de vous montrer tout Ã  l'heure avec le

03:21.199 --> 03:27.199
FOREACH, oÃ¹ on a fait Ã©tape numÃ©ro 1 jusqu'Ã  5,
si on veut obtenir le mÃªme rÃ©sultat avec cette

03:27.199 --> 03:32.039
seconde syntaxe, voici le code que l'on doit
Ã©crire. On voit que c'est un peu plus lourd en

03:32.039 --> 03:39.440
termes de syntaxe, mais on obtiendra strictement
le mÃªme rÃ©sultat. On dÃ©finit la variable $i qui

03:39.440 --> 03:47.199
est Ã©gale Ã  1 dÃ¨s le dÃ©part. On va Ã  chaque
fois faire plus 1 sur cette variable, d'oÃ¹ le i++

03:47.199 --> 03:52.000
qui va permettre d'incrÃ©menter de 1 la variable
Ã  chaque itÃ©ration. Ici c'est la condition de

03:52.000 --> 04:00.080
rÃ©pÃ©tition, donc il faut que i soit infÃ©rieur ou
Ã©gal Ã  5 pour qu'on continue Ã  itÃ©rer la boucle

04:00.720 --> 04:07.080
Si on exÃ©cute ce script, on va voir qu'on obtient
exactement le mÃªme rÃ©sultat que tout Ã  l'heure

04:07.399 --> 04:11.479
D'ailleurs vous avez la sortie des deux mÃ©thodes
et on a exactement la mÃªme chose, c'est simplement

04:11.479 --> 04:16.359
une histoire d'Ã©criture. AprÃ¨s c'est une histoire
d'Ã©criture, mais tout dÃ©pend de ce qu'on veut

04:16.359 --> 04:20.160
faire. Il y a des cas oÃ¹ on va directement
s'orienter vers le FOREACH, notamment si on

04:20.160 --> 04:25.440
veut parcourir l'intÃ©gralitÃ© d'un fichier. Ce
sera beaucoup plus simple que d'utiliser une boucle

04:25.440 --> 04:32.880
FOR tel que je viens de vous la montrer. Voici
un exemple autour de cette notion de fichier

04:32.880 --> 04:39.359
puisque lÃ  on va prendre la liste de tous
les fichiers .txt prÃ©sents dans le dossier

04:39.359 --> 04:45.399
Home Flow Documents, et on va exÃ©cuter une action
sur chacun de ces fichiers. On va pouvoir traiter

04:45.399 --> 04:51.000
de faÃ§on rÃ©pÃ©titive un ensemble de fichiers. J'ai
ma variable fichier qui sera interne Ã  la boucle

04:51.000 --> 04:57.440
et on va compter le nombre de lignes dans chacun
de ces fichiers. C'est une action trÃ¨s basique

04:57.440 --> 05:04.160
mais Ã§a vous montre un peu le potentiel des
boucles FOREACH en scripting batch. J'ai mon

05:04.160 --> 05:09.399
dollar fichier pour rappeler le nom de mon fichier
et pour l'afficher Ã  l'Ã©cran. Entre le dollar

05:09.399 --> 05:14.959
la parenthÃ¨se qui est lÃ  et la parenthÃ¨se qui
est lÃ , Ã§a me permet d'avoir Ã  l'intÃ©rieur de ce

05:14.959 --> 05:21.799
bloc une expression Ã  exÃ©cuter. Je vais exÃ©cuter
la commande CAT pour afficher le contenu du fichier

05:22.519 --> 05:27.959
Le pipeline je l'envoie Ã  wc-l pour compter
le nombre de lignes et l'afficher Ã  l'Ã©cran

05:27.959 --> 05:33.000
Et nous verrons que toute cette partie du script
sera remplacÃ©e simplement par un nombre de lignes

05:33.000 --> 05:40.359
Donc on va exÃ©cuter ce petit script lÃ , et j'ai
bien l'ensemble de mes fichiers .txt prÃ©sents

05:40.359 --> 05:44.440
dans ce dossier. Apparemment il y en a cinq, et Ã 
chaque fois j'ai le nombre de lignes qui apparaÃ®t

05:44.440 --> 05:50.519
Du coup on pourrait s'amuser mÃªme Ã  vÃ©rifier,
par exemple si on prend le fichier numÃ©ro 3

05:50.959 --> 05:56.079
on l'affiche. Alors effectivement il a bien une,
deux, trois lignes, ce qui a bien Ã©tÃ© retournÃ© ici

05:56.079 --> 05:59.720
Et donc on a pu faire cette action rÃ©pÃ©titive.
On aurait pu faire totalement autre chose

05:59.720 --> 06:03.600
mais on a vraiment fait une action rÃ©pÃ©titive
sur un ensemble de fichiers que l'on a souhaitÃ

06:03.600 --> 06:07.359
traiter. Je vais vous prÃ©senter un autre exemple
basÃ© sur la manipulation de fichiers, oÃ¹ cette

06:07.359 --> 06:12.040
fois-ci nous allons prendre la liste de tous les
fichiers .txt prÃ©sents dans le rÃ©pertoire courant

06:12.040 --> 06:21.000
Donc on voit bien ici que je n'ai pas prÃ©cisÃ© de chemin complet, ce qui veut dire qu'on va prendre
le rÃ©pertoire courant dans lequel on se situe au niveau du shell bash. Et donc on va faire une

06:21.000 --> 06:25.839
action de renommage, c'est Ã  dire qu'on va prendre
chaque fichier et on va le renommer en lui ajoutant

06:25.839 --> 06:32.160
le prÃ©fixe ITCONNECT. On pourrait renommer
en masse des fichiers avec un tel script

06:32.160 --> 06:40.920
Donc lÃ  c'est un exemple trÃ¨s simple, une nouvelle fois oÃ¹ j'ai simplement rajoutÃ© ITCONNECT,
mais Ã§a Ã©vite de le faire Ã  la main. Dans ce fichier lÃ , qu'est-ce que j'ai ? J'ai

06:41.040 --> 06:45.600
un document 1, un document 2, jusqu'Ã  5.
On va maintenant exÃ©cuter ce fameux script

06:45.600 --> 06:51.079
donc qui est celui-ci. Et en principe il n'y
a aucun retour console, ce qui est normal

06:51.079 --> 06:57.480
je n'ai pas inclus de Ã©cho dans ma boucle. Mais
maintenant si je refais un ls, j'ai bien pour le

06:57.480 --> 07:01.839
coup l'ensemble de mes documents qui ont Ã©tÃ©
renommÃ©s avec ITCONNECT, donc c'est bien le

07:01.839 --> 07:06.279
prÃ©fixe que j'ai souhaitÃ© ajouter. Je n'ai pas eu
Ã  le faire Ã  la main, donc lÃ  j'aurais eu 200

07:06.279 --> 07:14.079
fichiers Ã  traiter, Ã§a l'aurait fait trÃ¨s rapidement alors qu'Ã  la main Ã§a aurait Ã©tÃ©
relativement pÃ©nible. Donc on voit bien ici l'intÃ©rÃªt d'une boucle fort pour automatiser

07:14.079 --> 07:18.920
l'exÃ©cution de tÃ¢ches rÃ©pÃ©titives. Nous allons
Ã©tudier un autre exemple, toujours dans cette

07:18.920 --> 07:23.839
idÃ©e de vous montrer un petit peu le potentiel
de tout Ã§a. Ici j'ai dÃ©fini un tableau dans la

07:23.839 --> 07:29.239
variable SERVICE qui contient deux noms de
services SSH et APACHE2. On voit en mÃªme temps

07:29.239 --> 07:34.640
que dans un tableau, entre parenthÃ¨ses, on met les
valeurs, on les sÃ©pare par un espace. L'objectif

07:34.640 --> 07:40.480
va Ãªtre de parcourir ce tableau pour redÃ©marrer de
faÃ§on automatique les services qui sont prÃ©sents

07:40.480 --> 07:44.079
dans ce tableau. On peut imaginer que c'est
trÃ¨s intÃ©ressant sur un serveur quand on veut

07:44.079 --> 07:47.959
l'administrer. Si on a besoin de redÃ©marrer un
ensemble de services, plutÃ´t que d'enchaÃ®ner

07:47.959 --> 07:52.359
Ã  la main toutes les commandes en changeant le
nom du service Ã  chaque fois, on se fait un petit

07:52.359 --> 07:56.279
script comme Ã§a. On lance le script et derriÃ¨re
c'est lui qui va s'occuper de redÃ©marrer les

07:56.279 --> 08:02.640
services dans l'ordre tel qu'ils sont prÃ©cisÃ©s
dans la variable SERVICE. Je mets ici SERVICE

08:02.720 --> 08:08.440
sans S qui sera ma variable Ã  l'intÃ©rieur de
la boucle. Je vais parcourir l'ensemble de mon

08:08.440 --> 08:13.399
tableau. C'est pour Ã§a qu'ici j'ai utilisÃ© cette
syntaxe avec le arrow base pour sÃ©lectionner

08:13.399 --> 08:20.119
l'ensemble des Ã©lÃ©ments du tableau. Cela va
retourner tous les Ã©lÃ©ments. Le Ã©cho pour avoir

08:20.119 --> 08:25.799
une petite phrase de suivi dans la console et on
va un systÃ¨me CTL restart derriÃ¨re le nom du

08:25.799 --> 08:32.159
service. Je pourrais soit mettre le sudo directement
ici ou je peux mettre le sudo quand je vais

08:33.159 --> 08:38.719
le dire directement appelÃ© le script. Comme Ã§a,
cela va me permettre d'avoir l'Ã©lÃ©vation de

08:38.719 --> 08:46.640
privilÃ¨ges nÃ©cessaire pour redÃ©marrer les services. Cela me demande bien le mot de passe,
donc cela nous permet de voir aussi en mÃªme temps le fait que l'on puisse utiliser sudo pour

08:46.640 --> 08:51.400
exÃ©cuter un script qui nÃ©cessite une Ã©lÃ©vation
de privilÃ¨ges. LÃ  j'ai bien eu un redÃ©marrage de

08:51.400 --> 08:55.799
mes services. J'ai le suivi directement dans la
console qui est plutÃ´t intÃ©ressant. Pour finir

08:55.799 --> 09:00.400
voici un dernier exemple. Nous allons mixer
l'utilisation de la boucle fort avec les

09:00.400 --> 09:05.479
structures conditionnelles if-else. L'idÃ©e ici
c'est toujours d'avoir notre liste de services

09:05.479 --> 09:10.320
avec simplement deux services. On va parcourir
cette liste de services et on va vÃ©rifier l'Ã©tat

09:10.320 --> 09:19.479
de chacun des services prÃ©sents dans notre tableau.
L'idÃ©e c'est de faire un if. La condition du if

09:19.479 --> 09:27.320
c'est systÃ¨mectl isActive de faÃ§on silencieuse.
Le if tel qu'il est Ã©crit ici va permettre de

09:27.320 --> 09:33.080
vÃ©rifier que le service est actif et on ne va rien
retourner dans la console. C'est pour Ã§a que j'ai

09:33.080 --> 09:39.039
rajoutÃ© le quiet. Si le service est actif, on
retourne le service est actif en mettant le nom

09:39.039 --> 09:46.239
du service. Sinon, c'est qu'il est inactif. On
va pouvoir exÃ©cuter ce script. J'ai donc bien

09:46.239 --> 09:51.799
vÃ©rification de l'Ã©tat du service SSH. Le service
SSH est actif et la mÃªme chose pour Apache 2

09:51.799 --> 09:57.239
A chaque fois j'ai le retour console, puisque j'ai
bien une phrase qui Ã©tait ici pour l'ensemble

09:57.719 --> 10:02.080
de mes services Ã  traiter. Ensuite, en fonction de
l'Ã©tat du service en lui-mÃªme, on va retourner

10:02.080 --> 10:07.380
une valeur qui sera diffÃ©rente. Dans le cas
prÃ©sent, au niveau du if, on voit que je n'ai

10:07.380 --> 10:11.799
pas mis de crochet au niveau de la condition.
C'est normal, sinon Ã§a renverrait une erreur

10:11.799 --> 10:17.520
vis-Ã -vis du test qui a Ã©tÃ© fait dans le cas
prÃ©sent. Cela permet aussi de voir cette possibilitÃ©

10:17.520 --> 10:24.440
J'espÃ¨re que cette vidÃ©o vous a plu ! AprÃ¨s
l'avoir regardÃ©e, vous Ãªtes prÃªts Ã  mettre

10:24.440 --> 10:29.559
en pratique les boucles forts en scripting bash.
N'hÃ©sitez pas Ã  aller sur le site itconnect.fr

10:29.559 --> 10:33.400
puisque vous pouvez retrouver l'ensemble des
articles sur le scripting bash, et aussi l'ensemble

10:33.400 --> 10:37.000
des exemples, ce qui vous permet de faire des
copier-coller Ã©ventuellement des scripts que

10:37.000 --> 10:42.440
je vous prÃ©sente, pour les tester de votre cÃ´tÃ©,
ou pour les amÃ©liorer, les adapter Ã  vos besoins

10:42.440 --> 10:46.719
N'hÃ©sitez pas Ã  commenter cette vidÃ©o, Ã  me dire
ce que vous en pensez, Ã  la partager Ã©galement

10:46.719 --> 10:48.159
et puis je vous dis
Ã  trÃ¨s vite ! Ciao 
øüÏ	      gJngJnGrF³g;½Ñ   ‘    O^partitionKey=%28https%2Cit-connect.fr%29,a,~FETCH,:https://video-meta.humix.com/caption/YQQ-49oO38pr/570baec0b5a123af6ed0855aa7eb46b1_fr-FR.vtt necko:classified 1 strongly-framed 1 security-info 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 request-method GET request-Origin https://www.it-connect.fr request-Accept-Encoding gzip, deflate, br, zstd response-head HTTP/2 200 
date: Sat, 19 Oct 2024 05:58:06 GMT
content-type: text/vtt; charset=utf-8
content-length: 14803
access-control-allow-origin: *
content-disposition: inline
etag: "570baec0b5a123af6ed0855aa7eb46b1"
last-modified: Fri, 23 Aug 2024 16:40:53 GMT
vary: Origin, Accept-Encoding
cache-control: max-age=2678400
cf-cache-status: HIT
age: 27421
accept-ranges: bytes
report-to: {"endpoints":[{"url":"https:\/\/a.nel.cloudflare.com\/report\/v4?s=HtN0cEFYxJTMIwj2P%2B43CnK2rrhtRAmMslSS2Kiy%2Ft1oeQBlYeibEmDDm64YdxdVMofZb0PBQQ8Um3WrjzTLYMyrwG3OrzlBDibhfOWUArUzimrChFO9lYg1BNdFZoRs68d4p5T2iw%3D%3D"}],"group":"cf-nel","max_age":604800}
nel: {"success_fraction":0,"report_to":"cf-nel","max_age":604800}
server: cloudflare
cf-ray: 8d4e88cf9d22b79f-ABJ
alt-svc: h3=":443"; ma=86400
server-timing: cfL4;desc="?proto=TCP&rtt=5146&sent=34&recv=12&lost=0&retrans=0&sent_bytes=37143&recv_bytes=1686&delivery_rate=814277&cwnd=254&unsent_bytes=0&cid=4d7d6c9dffcba43d&ts=93&x=0"
X-Firefox-Spdy: h2
 original-response-headers date: Sat, 19 Oct 2024 05:58:06 GMT
content-type: text/vtt; charset=utf-8
content-length: 14803
access-control-allow-origin: *
content-disposition: inline
etag: "570baec0b5a123af6ed0855aa7eb46b1"
last-modified: Fri, 23 Aug 2024 16:40:53 GMT
vary: Origin, Accept-Encoding
cache-control: max-age=2678400
cf-cache-status: HIT
age: 27421
accept-ranges: bytes
report-to: {"endpoints":[{"url":"https:\/\/a.nel.cloudflare.com\/report\/v4?s=HtN0cEFYxJTMIwj2P%2B43CnK2rrhtRAmMslSS2Kiy%2Ft1oeQBlYeibEmDDm64YdxdVMofZb0PBQQ8Um3WrjzTLYMyrwG3OrzlBDibhfOWUArUzimrChFO9lYg1BNdFZoRs68d4p5T2iw%3D%3D"}],"group":"cf-nel","max_age":604800}
nel: {"success_fraction":0,"report_to":"cf-nel","max_age":604800}
server: cloudflare
cf-ray: 8d4e88cf9d22b79f-ABJ
alt-svc: h3=":443"; ma=86400
server-timing: cfL4;desc="?proto=TCP&rtt=5146&sent=34&recv=12&lost=0&retrans=0&sent_bytes=37143&recv_bytes=1686&delivery_rate=814277&cwnd=254&unsent_bytes=0&cid=4d7d6c9dffcba43d&ts=93&x=0"
X-Firefox-Spdy: h2
 ctid 1 net-response-time-onstart 129 net-response-time-onstop 129   9Ó